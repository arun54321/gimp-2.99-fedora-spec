From 58fba610fbde37069f7b711b80d84972957f6034 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Fri, 27 Nov 2020 20:48:11 +0300
Subject: [PATCH 01/16] clutter: Record flip time

Will be used for intelligent max render time computation (aka repaint
scheduling).
---
 clutter/clutter/clutter-frame-clock.c | 10 ++++++++++
 clutter/clutter/clutter-frame-clock.h |  3 +++
 clutter/clutter/clutter-stage-view.c  |  3 +++
 3 files changed, 16 insertions(+)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 05e79e6626..c5acf51ad5 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -76,6 +76,9 @@ struct _ClutterFrameClock
   gboolean is_next_presentation_time_valid;
   int64_t next_presentation_time_us;
 
+  /* Last KMS buffer submission time. */
+  int64_t last_flip_time_us;
+
   gboolean pending_reschedule;
   gboolean pending_reschedule_now;
 
@@ -548,6 +551,13 @@ frame_clock_source_dispatch (GSource     *source,
   return G_SOURCE_CONTINUE;
 }
 
+void
+clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
+                                      int64_t            flip_time_us)
+{
+  frame_clock->last_flip_time_us = flip_time_us;
+}
+
 static GSourceFuncs frame_clock_source_funcs = {
   NULL,
   NULL,
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index 9f91b6bfd3..b7120aade8 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -90,4 +90,7 @@ void clutter_frame_clock_remove_timeline (ClutterFrameClock *frame_clock,
 CLUTTER_EXPORT
 float clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock);
 
+void clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
+                                           int64_t            flip_time_us);
+
 #endif /* CLUTTER_FRAME_CLOCK_H */
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index b44bf88854..d6755e3c4e 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -1187,6 +1187,9 @@ handle_frame_clock_frame (ClutterFrameClock *frame_clock,
 
       _clutter_stage_window_redraw_view (stage_window, view, &frame);
 
+      clutter_frame_clock_record_flip_time (frame_clock,
+                                            g_get_monotonic_time ());
+
       clutter_stage_emit_after_paint (stage, view);
 
       if (_clutter_context_get_show_fps ())
-- 
GitLab


From 020c1f377a87b28020fedf8de3c028991e293c29 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 11:36:04 +0300
Subject: [PATCH 02/16] backends/native: Add
 meta_calculate_drm_mode_vblank_duration_us()

Computes the vblank duration from mode timings.
---
 src/backends/native/meta-kms-utils.c |  21 ++++++
 src/backends/native/meta-kms-utils.h |   3 +
 src/tests/kms-utils-unit-tests.c     | 107 ++++++++++++++++++++++++++-
 3 files changed, 127 insertions(+), 4 deletions(-)

diff --git a/src/backends/native/meta-kms-utils.c b/src/backends/native/meta-kms-utils.c
index 1c58db83d5..2289cfa918 100644
--- a/src/backends/native/meta-kms-utils.c
+++ b/src/backends/native/meta-kms-utils.c
@@ -47,6 +47,27 @@ meta_calculate_drm_mode_refresh_rate (const drmModeModeInfo *drm_mode)
   return numerator / denominator;
 }
 
+int64_t
+meta_calculate_drm_mode_vblank_duration_us (const drmModeModeInfo *drm_mode)
+{
+  int64_t value;
+
+  if (drm_mode->htotal <= 0 || drm_mode->vtotal <= 0)
+    return 0;
+
+  /* Convert to int64_t early. */
+  value = drm_mode->vtotal - drm_mode->vdisplay;
+  value *= drm_mode->htotal;
+
+  if (drm_mode->flags & DRM_MODE_FLAG_DBLSCAN)
+    value *= 2;
+
+  /* Round the duration up as it is used for buffer swap deadline computation. */
+  value = (value * 1000 + drm_mode->clock - 1) / drm_mode->clock;
+
+  return value;
+}
+
 /**
  * meta_drm_format_to_string:
  * @tmp: temporary buffer
diff --git a/src/backends/native/meta-kms-utils.h b/src/backends/native/meta-kms-utils.h
index c22ceaaa0f..2f2bad1f90 100644
--- a/src/backends/native/meta-kms-utils.h
+++ b/src/backends/native/meta-kms-utils.h
@@ -34,6 +34,9 @@ typedef struct _MetaDrmFormatBuf
 META_EXPORT_TEST
 float meta_calculate_drm_mode_refresh_rate (const drmModeModeInfo *drm_mode);
 
+META_EXPORT_TEST
+int64_t meta_calculate_drm_mode_vblank_duration_us (const drmModeModeInfo *drm_mode);
+
 const char * meta_drm_format_to_string (MetaDrmFormatBuf *tmp,
                                         uint32_t          drm_format);
 
diff --git a/src/tests/kms-utils-unit-tests.c b/src/tests/kms-utils-unit-tests.c
index 743d46e0eb..2955375bd7 100644
--- a/src/tests/kms-utils-unit-tests.c
+++ b/src/tests/kms-utils-unit-tests.c
@@ -26,9 +26,9 @@
 typedef struct {
   drmModeModeInfo drm_mode;
   float expected_refresh_rate;
-} ModeInfoTestCase;
+} RefreshRateTestCase;
 
-static const ModeInfoTestCase test_cases[] = {
+static const RefreshRateTestCase refresh_rate_test_cases[] = {
   /* "cvt 640 480" */
   {
     .drm_mode = {
@@ -125,9 +125,9 @@ refresh_rate (void)
 {
   size_t index;
 
-  for (index = 0; index < G_N_ELEMENTS(test_cases); index++)
+  for (index = 0; index < G_N_ELEMENTS (refresh_rate_test_cases); index++)
     {
-      const ModeInfoTestCase *test_case = test_cases + index;
+      const RefreshRateTestCase *test_case = refresh_rate_test_cases + index;
       float refresh_rate;
 
       refresh_rate =
@@ -138,8 +138,107 @@ refresh_rate (void)
     }
 }
 
+typedef struct {
+  drmModeModeInfo drm_mode;
+  int64_t expected_vblank_duration_us;
+} VblankDurationTestCase;
+
+static const VblankDurationTestCase vblank_duration_test_cases[] = {
+  /* "cvt 640 480" */
+  {
+    .drm_mode = {
+      .clock = 23975,
+      .hdisplay = 640,
+      .hsync_start = 664,
+      .hsync_end = 720,
+      .htotal = 800,
+      .vdisplay = 480,
+      .vsync_start = 483,
+      .vsync_end = 487,
+      .vtotal = 500,
+      .vscan = 0,
+      .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC,
+    },
+    .expected_vblank_duration_us = 668,
+  },
+
+  /* "cvt 640 480" with htotal 0 */
+  {
+    .drm_mode = {
+       .clock = 23975,
+       .hdisplay = 640,
+       .hsync_start = 664,
+       .hsync_end = 720,
+       .htotal = 0,
+       .vdisplay = 480,
+       .vsync_start = 483,
+       .vsync_end = 487,
+       .vtotal = 500,
+       .vscan = 0,
+       .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC,
+    },
+    .expected_vblank_duration_us = 0,
+  },
+
+  /* "cvt 640 480" with vtotal 0 */
+  {
+    .drm_mode = {
+      .clock = 23975,
+      .hdisplay = 640,
+      .hsync_start = 664,
+      .hsync_end = 720,
+      .htotal = 800,
+      .vdisplay = 480,
+      .vsync_start = 483,
+      .vsync_end = 487,
+      .vtotal = 0,
+      .vscan = 0,
+      .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC,
+    },
+    .expected_vblank_duration_us = 0,
+  },
+
+  /* "cvt 640 480" with DBLSCAN */
+  {
+    .drm_mode = {
+      .clock = 23975,
+      .hdisplay = 640,
+      .hsync_start = 664,
+      .hsync_end = 720,
+      .htotal = 800,
+      .vdisplay = 480,
+      .vsync_start = 483,
+      .vsync_end = 487,
+      .vtotal = 500,
+      .vscan = 0,
+      .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC |
+               DRM_MODE_FLAG_DBLSCAN,
+    },
+    .expected_vblank_duration_us = 1335,
+  },
+};
+
+static void
+vblank_duration (void)
+{
+  size_t index;
+
+  for (index = 0; index < G_N_ELEMENTS (vblank_duration_test_cases); index++)
+    {
+      const VblankDurationTestCase *test_case = vblank_duration_test_cases + index;
+      int64_t vblank_duration_us;
+
+      vblank_duration_us =
+        meta_calculate_drm_mode_vblank_duration_us (&test_case->drm_mode);
+      g_assert_cmpint (vblank_duration_us,
+                       ==,
+                       test_case->expected_vblank_duration_us);
+    }
+}
+
 void
 init_kms_utils_tests (void)
 {
   g_test_add_func ("/kms-utils/refresh-rate", refresh_rate);
+  g_test_add_func ("/kms-utils/vblank-duration", vblank_duration);
 }
-- 
GitLab


From acfd707c03e16b259acae8ba256571010e4512d3 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 11:37:35 +0300
Subject: [PATCH 03/16] backends: Add vblank duration to MetaCrtcModeInfo

---
 src/backends/meta-crtc-mode.h            | 1 +
 src/backends/native/meta-crtc-mode-kms.c | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/src/backends/meta-crtc-mode.h b/src/backends/meta-crtc-mode.h
index 87778b8662..2ac90e4089 100644
--- a/src/backends/meta-crtc-mode.h
+++ b/src/backends/meta-crtc-mode.h
@@ -54,6 +54,7 @@ typedef struct _MetaCrtcModeInfo
   int width;
   int height;
   float refresh_rate;
+  int64_t vblank_duration_us;
   MetaCrtcModeFlag flags;
 } MetaCrtcModeInfo;
 
diff --git a/src/backends/native/meta-crtc-mode-kms.c b/src/backends/native/meta-crtc-mode-kms.c
index 6f190edc4a..053367cfd1 100644
--- a/src/backends/native/meta-crtc-mode-kms.c
+++ b/src/backends/native/meta-crtc-mode-kms.c
@@ -55,6 +55,8 @@ meta_crtc_mode_kms_new (MetaKmsMode *kms_mode,
   crtc_mode_info->flags = drm_mode->flags;
   crtc_mode_info->refresh_rate =
     meta_calculate_drm_mode_refresh_rate (drm_mode);
+  crtc_mode_info->vblank_duration_us =
+    meta_calculate_drm_mode_vblank_duration_us (drm_mode);
 
   crtc_mode_name = g_strndup (drm_mode->name, DRM_DISPLAY_MODE_LEN);
   mode_kms = g_object_new (META_TYPE_CRTC_MODE_KMS,
-- 
GitLab


From 306ad33ebbcd8f07fb3f5050413bc9b3a4300979 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:18:26 +0300
Subject: [PATCH 04/16] clutter: Add vblank duration to ClutterStageView

---
 clutter/clutter/clutter-stage-view.c       | 17 +++++++++++++++++
 src/backends/native/meta-renderer-native.c |  1 +
 2 files changed, 18 insertions(+)

diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index d6755e3c4e..0f8f7c6ee7 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -43,6 +43,7 @@ enum
   PROP_USE_SHADOWFB,
   PROP_SCALE,
   PROP_REFRESH_RATE,
+  PROP_VBLANK_DURATION_US,
 
   PROP_LAST
 };
@@ -79,6 +80,7 @@ typedef struct _ClutterStageViewPrivate
   cairo_region_t *redraw_clip;
 
   float refresh_rate;
+  int64_t vblank_duration_us;
   ClutterFrameClock *frame_clock;
 
   struct {
@@ -1298,6 +1300,9 @@ clutter_stage_view_get_property (GObject    *object,
     case PROP_REFRESH_RATE:
       g_value_set_float (value, priv->refresh_rate);
       break;
+    case PROP_VBLANK_DURATION_US:
+      g_value_set_int64 (value, priv->vblank_duration_us);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1341,6 +1346,9 @@ clutter_stage_view_set_property (GObject      *object,
     case PROP_REFRESH_RATE:
       priv->refresh_rate = g_value_get_float (value);
       break;
+    case PROP_VBLANK_DURATION_US:
+      priv->vblank_duration_us = g_value_get_int64 (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
     }
@@ -1500,5 +1508,14 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
                         G_PARAM_CONSTRUCT |
                         G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_VBLANK_DURATION_US] =
+    g_param_spec_int64 ("vblank-duration-us",
+                        "Vblank duration (µs)",
+                        "The vblank duration",
+                        0, G_MAXINT64, 0,
+                        G_PARAM_READWRITE |
+                        G_PARAM_CONSTRUCT_ONLY |
+                        G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index f12e2dda74..f2c475dc6c 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1111,6 +1111,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                        "use-shadowfb", use_shadowfb,
                        "transform", view_transform,
                        "refresh-rate", crtc_mode_info->refresh_rate,
+                       "vblank-duration-us", crtc_mode_info->vblank_duration_us,
                        NULL);
 
   if (META_IS_ONSCREEN_NATIVE (framebuffer))
-- 
GitLab


From 6d3aa1efb4939a03c96ce1013a5f83b6c51d72f4 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:20:01 +0300
Subject: [PATCH 05/16] clutter: Store vblank duration in ClutterFrameClock

---
 clutter/clutter/clutter-frame-clock.c            |  6 ++++++
 clutter/clutter/clutter-frame-clock.h            |  1 +
 clutter/clutter/clutter-stage-view.c             |  1 +
 src/tests/clutter/conform/frame-clock-timeline.c |  3 +++
 src/tests/clutter/conform/frame-clock.c          | 11 +++++++++++
 5 files changed, 22 insertions(+)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index c5acf51ad5..9dbed99ba4 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -76,6 +76,10 @@ struct _ClutterFrameClock
   gboolean is_next_presentation_time_valid;
   int64_t next_presentation_time_us;
 
+  /* Buffer must be submitted to KMS and GPU rendering must be finished
+   * this amount of time before the next presentation time.
+   */
+  int64_t vblank_duration_us;
   /* Last KMS buffer submission time. */
   int64_t last_flip_time_us;
 
@@ -587,6 +591,7 @@ init_frame_clock_source (ClutterFrameClock *frame_clock)
 
 ClutterFrameClock *
 clutter_frame_clock_new (float                            refresh_rate,
+                         int64_t                          vblank_duration_us,
                          const ClutterFrameListenerIface *iface,
                          gpointer                         user_data)
 {
@@ -602,6 +607,7 @@ clutter_frame_clock_new (float                            refresh_rate,
   init_frame_clock_source (frame_clock);
 
   frame_clock->refresh_rate = refresh_rate;
+  frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
 }
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index b7120aade8..c825ecad94 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -56,6 +56,7 @@ typedef struct _ClutterFrameListenerIface
 
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
+                                             int64_t                          vblank_duration_us,
                                              const ClutterFrameListenerIface *iface,
                                              gpointer                         user_data);
 
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 0f8f7c6ee7..2b2cadd684 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -1365,6 +1365,7 @@ clutter_stage_view_constructed (GObject *object)
     init_shadowfb (view);
 
   priv->frame_clock = clutter_frame_clock_new (priv->refresh_rate,
+                                               priv->vblank_duration_us,
                                                &frame_clock_listener_iface,
                                                view);
 
diff --git a/src/tests/clutter/conform/frame-clock-timeline.c b/src/tests/clutter/conform/frame-clock-timeline.c
index bf99cd17b4..0f9f04d794 100644
--- a/src/tests/clutter/conform/frame-clock-timeline.c
+++ b/src/tests/clutter/conform/frame-clock-timeline.c
@@ -64,6 +64,7 @@ frame_clock_timeline_basic (void)
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &timeline_frame_listener_iface,
                                          NULL);
   g_object_add_weak_pointer (G_OBJECT (frame_clock), (gpointer *) &frame_clock);
@@ -143,10 +144,12 @@ frame_clock_timeline_switch (void)
   main_loop = g_main_loop_new (NULL, FALSE);
 
   frame_clock1 = clutter_frame_clock_new (refresh_rate,
+                                          0,
                                           &timeline_frame_listener_iface,
                                           NULL);
   g_object_add_weak_pointer (G_OBJECT (frame_clock1), (gpointer *) &frame_clock1);
   frame_clock2 = clutter_frame_clock_new (refresh_rate,
+                                          0,
                                           &timeline_frame_listener_iface,
                                           NULL);
   g_object_add_weak_pointer (G_OBJECT (frame_clock2), (gpointer *) &frame_clock2);
diff --git a/src/tests/clutter/conform/frame-clock.c b/src/tests/clutter/conform/frame-clock.c
index 45d21ccec2..810c39a02c 100644
--- a/src/tests/clutter/conform/frame-clock.c
+++ b/src/tests/clutter/conform/frame-clock.c
@@ -146,6 +146,7 @@ frame_clock_schedule_update (void)
 
   test.main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &frame_listener_iface,
                                          &test);
 
@@ -228,6 +229,7 @@ frame_clock_immediate_present (void)
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &immediate_frame_listener_iface,
                                          main_loop);
 
@@ -306,6 +308,7 @@ frame_clock_delayed_damage (void)
 
   test.main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &delayed_damage_frame_listener_iface,
                                          &test);
 
@@ -366,6 +369,7 @@ frame_clock_no_damage (void)
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &no_damage_frame_listener_iface,
                                          NULL);
 
@@ -452,6 +456,7 @@ frame_clock_schedule_update_now (void)
 
   test.base.main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &update_now_frame_listener_iface,
                                          &test);
 
@@ -534,6 +539,7 @@ frame_clock_before_frame (void)
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &before_frame_frame_listener_iface,
                                          &expected_frame_count);
 
@@ -615,6 +621,7 @@ frame_clock_inhibit (void)
 
   test.main_loop = g_main_loop_new (NULL, FALSE);
   test.frame_clock = clutter_frame_clock_new (refresh_rate,
+                                              0,
                                               &inhibit_frame_listener_iface,
                                               &test);
 
@@ -678,6 +685,7 @@ frame_clock_reschedule_on_idle (void)
 
   test.base.main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &reschedule_on_idle_listener_iface,
                                          &test);
   fake_hw_clock = fake_hw_clock_new (frame_clock, NULL, NULL);
@@ -714,6 +722,7 @@ frame_clock_destroy_signal (void)
   /* Test that the destroy signal is emitted when removing last reference. */
 
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &dummy_frame_listener_iface,
                                          NULL);
 
@@ -732,6 +741,7 @@ frame_clock_destroy_signal (void)
    */
 
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &dummy_frame_listener_iface,
                                          NULL);
   frame_clock_backup = frame_clock;
@@ -802,6 +812,7 @@ frame_clock_notify_ready (void)
 
   main_loop = g_main_loop_new (NULL, FALSE);
   frame_clock = clutter_frame_clock_new (refresh_rate,
+                                         0,
                                          &frame_clock_ready_listener_iface,
                                          main_loop);
 
-- 
GitLab


From f87454ed390011f377e4377d32556c3195c5bd3b Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:32:57 +0300
Subject: [PATCH 06/16] cogl: Add prototypes for getting timestamp queries

Will be used for measuring GPU rendering duration.
---
 cogl/cogl/gl-prototypes/cogl-all-functions.h | 28 ++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/cogl/cogl/gl-prototypes/cogl-all-functions.h b/cogl/cogl/gl-prototypes/cogl-all-functions.h
index a0c6395af2..7db1af9e26 100644
--- a/cogl/cogl/gl-prototypes/cogl-all-functions.h
+++ b/cogl/cogl/gl-prototypes/cogl-all-functions.h
@@ -247,3 +247,31 @@ COGL_EXT_BEGIN (multitexture_part1, 1, 3,
 COGL_EXT_FUNCTION (void, glClientActiveTexture,
                    (GLenum                texture))
 COGL_EXT_END ()
+
+COGL_EXT_BEGIN (query_counter, 3, 3,
+                0,
+                "ARB\0",
+                "timer_query\0")
+COGL_EXT_FUNCTION (void, glQueryCounter,
+                   (GLuint id, GLenum target))
+COGL_EXT_FUNCTION (void, glGetQueryObjecti64v,
+                   (GLuint id, GLenum pname, GLint64 *params))
+COGL_EXT_END ()
+
+COGL_EXT_BEGIN (get_int64, 3, 3,
+                0,
+                "\0",
+                "\0")
+COGL_EXT_FUNCTION (void, glGetInteger64v,
+                   (GLenum pname, GLint64 *params))
+COGL_EXT_END ()
+
+COGL_EXT_BEGIN (queries, 1, 5,
+                0,
+                "\0",
+                "\0")
+COGL_EXT_FUNCTION (void, glGenQueries,
+                   (GLsizei n, GLuint *ids))
+COGL_EXT_FUNCTION (void, glDeleteQueries,
+                   (GLsizei n, const GLuint *ids))
+COGL_EXT_END ()
-- 
GitLab


From 8a16f921bd2faa2c0ef386349fe966fde5623391 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:37:13 +0300
Subject: [PATCH 07/16] cogl: Add CPU swap time and GPU rendering query to
 CoglFrameInfo

---
 clutter/clutter/cogl/clutter-stage-cogl.c     |  9 ++++---
 cogl/cogl/cogl-frame-info-private.h           | 10 ++++++-
 cogl/cogl/cogl-frame-info.c                   | 27 ++++++++++++++++++-
 cogl/cogl/cogl-frame-info.h                   |  6 +++++
 .../x11/nested/meta-stage-x11-nested.c        |  3 ++-
 5 files changed, 49 insertions(+), 6 deletions(-)

diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index 5e81899b06..b40dfe2b1c 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -254,6 +254,7 @@ swap_framebuffer (ClutterStageWindow *stage_window,
   ClutterStageCoglPrivate *priv =
     _clutter_stage_cogl_get_instance_private (stage_cogl);
   CoglFramebuffer *framebuffer = clutter_stage_view_get_onscreen (view);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
 
   clutter_stage_view_before_swap_buffer (view, swap_region);
 
@@ -276,7 +277,7 @@ swap_framebuffer (ClutterStageWindow *stage_window,
           damage[i * 4 + 3] = rect.height;
         }
 
-      frame_info = cogl_frame_info_new (priv->global_frame_counter);
+      frame_info = cogl_frame_info_new (context, priv->global_frame_counter);
       priv->global_frame_counter++;
 
       /* push on the screen */
@@ -688,6 +689,7 @@ clutter_stage_cogl_scanout_view (ClutterStageCogl  *stage_cogl,
   ClutterStageCoglPrivate *priv =
     _clutter_stage_cogl_get_instance_private (stage_cogl);
   CoglFramebuffer *framebuffer = clutter_stage_view_get_framebuffer (view);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglOnscreen *onscreen;
   CoglFrameInfo *frame_info;
 
@@ -695,7 +697,7 @@ clutter_stage_cogl_scanout_view (ClutterStageCogl  *stage_cogl,
 
   onscreen = COGL_ONSCREEN (framebuffer);
 
-  frame_info = cogl_frame_info_new (priv->global_frame_counter);
+  frame_info = cogl_frame_info_new (context, priv->global_frame_counter);
 
   if (!cogl_onscreen_direct_scanout (onscreen,
                                      scanout,
@@ -748,9 +750,10 @@ clutter_stage_cogl_add_onscreen_frame_info (ClutterStageCogl *stage_cogl,
   ClutterStageCoglPrivate *priv =
     _clutter_stage_cogl_get_instance_private (stage_cogl);
   CoglFramebuffer *framebuffer = clutter_stage_view_get_onscreen (view);
+  CoglContext *context = cogl_framebuffer_get_context (framebuffer);
   CoglFrameInfo *frame_info;
 
-  frame_info = cogl_frame_info_new (priv->global_frame_counter);
+  frame_info = cogl_frame_info_new (context, priv->global_frame_counter);
   priv->global_frame_counter++;
 
   cogl_onscreen_add_frame_info (COGL_ONSCREEN (framebuffer), frame_info);
diff --git a/cogl/cogl/cogl-frame-info-private.h b/cogl/cogl/cogl-frame-info-private.h
index 81904f7a42..22d60c895e 100644
--- a/cogl/cogl/cogl-frame-info-private.h
+++ b/cogl/cogl/cogl-frame-info-private.h
@@ -33,6 +33,7 @@
 
 #include "cogl-frame-info.h"
 #include "cogl-object-private.h"
+#include "cogl-context.h"
 
 typedef enum _CoglFrameInfoFlag
 {
@@ -62,6 +63,8 @@ struct _CoglFrameInfo
 {
   CoglObject _parent;
 
+  CoglContext *context;
+
   int64_t frame_counter;
   int64_t presentation_time_us; /* CLOCK_MONOTONIC */
   float refresh_rate;
@@ -71,9 +74,14 @@ struct _CoglFrameInfo
   CoglFrameInfoFlag flags;
 
   unsigned int sequence;
+
+  unsigned timestamp_query;
+  int64_t gpu_time_before_buffer_swap_ns;
+  int64_t cpu_time_before_buffer_swap_us;
 };
 
 COGL_EXPORT
-CoglFrameInfo *cogl_frame_info_new (int64_t global_frame_counter);
+CoglFrameInfo *cogl_frame_info_new (CoglContext *context,
+                                    int64_t      global_frame_counter);
 
 #endif /* __COGL_FRAME_INFO_PRIVATE_H */
diff --git a/cogl/cogl/cogl-frame-info.c b/cogl/cogl/cogl-frame-info.c
index a31d916896..a55472344d 100644
--- a/cogl/cogl/cogl-frame-info.c
+++ b/cogl/cogl/cogl-frame-info.c
@@ -32,6 +32,7 @@
 
 #include "cogl-frame-info-private.h"
 #include "cogl-gtype-private.h"
+#include "cogl-context-private.h"
 
 static void _cogl_frame_info_free (CoglFrameInfo *info);
 
@@ -39,11 +40,12 @@ COGL_OBJECT_DEFINE (FrameInfo, frame_info);
 COGL_GTYPE_DEFINE_CLASS (FrameInfo, frame_info);
 
 CoglFrameInfo *
-cogl_frame_info_new (int64_t global_frame_counter)
+cogl_frame_info_new (CoglContext *context, int64_t global_frame_counter)
 {
   CoglFrameInfo *info;
 
   info = g_new0 (CoglFrameInfo, 1);
+  info->context = context;
   info->global_frame_counter = global_frame_counter;
 
   return _cogl_frame_info_object_new (info);
@@ -52,6 +54,9 @@ cogl_frame_info_new (int64_t global_frame_counter)
 static void
 _cogl_frame_info_free (CoglFrameInfo *info)
 {
+  if (info->timestamp_query)
+    info->context->glDeleteQueries (1, &info->timestamp_query);
+
   g_free (info);
 }
 
@@ -114,3 +119,23 @@ cogl_frame_info_get_sequence (CoglFrameInfo *info)
 
   return info->sequence;
 }
+
+int64_t
+cogl_frame_info_get_rendering_duration_ns (CoglFrameInfo *info)
+{
+  int64_t gpu_time_rendering_done_ns;
+
+  if (info->timestamp_query == 0)
+    return 0;
+
+  info->context->glGetQueryObjecti64v (info->timestamp_query,
+                                       0x8866, /* GL_QUERY_RESULT */
+                                       &gpu_time_rendering_done_ns);
+
+  return gpu_time_rendering_done_ns - info->gpu_time_before_buffer_swap_ns;
+}
+
+int64_t cogl_frame_info_get_time_before_buffer_swap_us (CoglFrameInfo *info)
+{
+  return info->cpu_time_before_buffer_swap_us;
+}
diff --git a/cogl/cogl/cogl-frame-info.h b/cogl/cogl/cogl-frame-info.h
index 7278a08ca6..c0ff12bc17 100644
--- a/cogl/cogl/cogl-frame-info.h
+++ b/cogl/cogl/cogl-frame-info.h
@@ -150,6 +150,12 @@ gboolean cogl_frame_info_is_vsync (CoglFrameInfo *info);
 COGL_EXPORT
 unsigned int cogl_frame_info_get_sequence (CoglFrameInfo *info);
 
+COGL_EXPORT
+int64_t cogl_frame_info_get_rendering_duration_ns (CoglFrameInfo *info);
+
+COGL_EXPORT
+int64_t cogl_frame_info_get_time_before_buffer_swap_us (CoglFrameInfo *info);
+
 G_END_DECLS
 
 #endif /* __COGL_FRAME_INFO_H */
diff --git a/src/backends/x11/nested/meta-stage-x11-nested.c b/src/backends/x11/nested/meta-stage-x11-nested.c
index 7a6c14a09f..b164867061 100644
--- a/src/backends/x11/nested/meta-stage-x11-nested.c
+++ b/src/backends/x11/nested/meta-stage-x11-nested.c
@@ -168,6 +168,7 @@ meta_stage_x11_nested_finish_frame (ClutterStageWindow *stage_window,
   MetaRenderer *renderer = meta_backend_get_renderer (backend);
   ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
   CoglFramebuffer *onscreen = COGL_FRAMEBUFFER (stage_x11->onscreen);
+  CoglContext *context = cogl_framebuffer_get_context (onscreen);
   GList *l;
   CoglFrameInfo *frame_info;
 
@@ -195,7 +196,7 @@ meta_stage_x11_nested_finish_frame (ClutterStageWindow *stage_window,
       draw_view (stage_nested, renderer_view, texture);
     }
 
-  frame_info = cogl_frame_info_new (0);
+  frame_info = cogl_frame_info_new (context, 0);
   cogl_onscreen_swap_buffers (stage_x11->onscreen, frame_info, frame);
 
   if (!clutter_frame_has_result (frame))
-- 
GitLab


From cd4f2c088d34c9d2d68c9c9cd73b7cb9fe95098f Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:39:30 +0300
Subject: [PATCH 08/16] cogl: Store CPU and GPU rendering timestamps in frame
 info

---
 cogl/cogl/winsys/cogl-onscreen-egl.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/cogl/cogl/winsys/cogl-onscreen-egl.c b/cogl/cogl/winsys/cogl-onscreen-egl.c
index 347e2071cb..d8fd77bb03 100644
--- a/cogl/cogl/winsys/cogl-onscreen-egl.c
+++ b/cogl/cogl/winsys/cogl-onscreen-egl.c
@@ -28,10 +28,15 @@
 #include "winsys/cogl-onscreen-egl.h"
 
 #include "cogl-context-private.h"
+#include "cogl-frame-info-private.h"
 #include "cogl-renderer-private.h"
 #include "cogl-trace.h"
 #include "winsys/cogl-winsys-egl-private.h"
 
+#ifndef GL_TIMESTAMP
+#define GL_TIMESTAMP 0x8E28
+#endif
+
 typedef struct _CoglOnscreenEglPrivate
 {
   EGLSurface egl_surface;
@@ -269,6 +274,19 @@ cogl_onscreen_egl_swap_buffers_with_damage (CoglOnscreen  *onscreen,
                                         COGL_FRAMEBUFFER (onscreen),
                                         COGL_FRAMEBUFFER_STATE_BIND);
 
+  if (context->glGenQueries && context->glQueryCounter && context->glGetInteger64v)
+    {
+      /* Set up a timestamp query for when all rendering will be finished. */
+      context->glGenQueries (1, &info->timestamp_query);
+      context->glQueryCounter (info->timestamp_query, GL_TIMESTAMP);
+
+      /* Get current GPU time. */
+      context->glGetInteger64v (GL_TIMESTAMP,
+                                &info->gpu_time_before_buffer_swap_ns);
+    }
+
+  info->cpu_time_before_buffer_swap_us = g_get_monotonic_time ();
+
   if (n_rectangles && egl_renderer->pf_eglSwapBuffersWithDamage)
     {
       CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-- 
GitLab


From ec1c0bbbdfa3e972e7d7b0568dd0d9fc3d650f4c Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:42:33 +0300
Subject: [PATCH 09/16] backends/native: Get rendering and swap timings during
 scanout

Scanout doesn't go through the usual path of compositing and doing
eglSwapBuffers, therefore it doesn't hit the timestamp query placed in
that path. Instead, get the timings by binding the scanout buffer to an
FBO and doing a timestamp query on the FBO.
---
 src/backends/native/meta-drm-buffer-gbm.c  | 118 +++++++++++++++++++++
 src/backends/native/meta-drm-buffer-gbm.h  |   3 +
 src/backends/native/meta-onscreen-native.c |  20 ++++
 3 files changed, 141 insertions(+)

diff --git a/src/backends/native/meta-drm-buffer-gbm.c b/src/backends/native/meta-drm-buffer-gbm.c
index 48ee9eb048..cb71c1d1a6 100644
--- a/src/backends/native/meta-drm-buffer-gbm.c
+++ b/src/backends/native/meta-drm-buffer-gbm.c
@@ -33,6 +33,10 @@
 #include "backends/native/meta-drm-buffer-private.h"
 #include "backends/native/meta-cogl-utils.h"
 
+#ifndef GL_TIMESTAMP
+#define GL_TIMESTAMP 0x8E28
+#endif
+
 struct _MetaDrmBufferGbm
 {
   MetaDrmBuffer parent;
@@ -190,6 +194,120 @@ meta_drm_buffer_gbm_new_take (MetaKmsDevice  *device,
   return buffer_gbm;
 }
 
+void
+meta_drm_buffer_gbm_fill_timings (MetaDrmBufferGbm *buffer_gbm,
+                                  CoglFrameInfo    *info)
+{
+  MetaBackend *backend = meta_get_backend ();
+  MetaEgl *egl = meta_backend_get_egl (backend);
+  ClutterBackend *clutter_backend =
+    meta_backend_get_clutter_backend (backend);
+  CoglContext *cogl_context =
+    clutter_backend_get_cogl_context (clutter_backend);
+  CoglDisplay *cogl_display = cogl_context->display;
+  CoglRenderer *cogl_renderer = cogl_display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  EGLDisplay egl_display = cogl_renderer_egl->edpy;
+  g_autoptr (GError) error = NULL;
+  EGLImageKHR egl_image;
+  CoglPixelFormat cogl_format;
+  CoglEglImageFlags flags;
+  g_autoptr (CoglOffscreen) cogl_fbo = NULL;
+  CoglTexture2D *cogl_tex;
+  uint32_t n_planes;
+  uint64_t *modifiers;
+  uint32_t *strides;
+  uint32_t *offsets;
+  uint32_t width;
+  uint32_t height;
+  uint32_t drm_format;
+  int *fds;
+  gboolean result;
+  int dmabuf_fd = -1;
+  uint32_t i;
+
+  if (!cogl_context->glGenQueries ||
+      !cogl_context->glQueryCounter ||
+      !cogl_context->glGetInteger64v)
+    return;
+
+  if (!buffer_gbm->bo)
+    return;
+
+  dmabuf_fd = gbm_bo_get_fd (buffer_gbm->bo);
+  if (dmabuf_fd == -1)
+    return;
+
+  drm_format = gbm_bo_get_format (buffer_gbm->bo);
+  result = meta_cogl_pixel_format_from_drm_format (drm_format,
+                                                   &cogl_format,
+                                                   NULL);
+  g_assert (result);
+
+  width = gbm_bo_get_width (buffer_gbm->bo);
+  height = gbm_bo_get_height (buffer_gbm->bo);
+  n_planes = gbm_bo_get_plane_count (buffer_gbm->bo);
+  fds = g_alloca (sizeof (int) * n_planes);
+  strides = g_alloca (sizeof (uint32_t) * n_planes);
+  offsets = g_alloca (sizeof (uint32_t) * n_planes);
+  modifiers = g_alloca (sizeof (uint64_t) * n_planes);
+
+  for (i = 0; i < n_planes; i++)
+    {
+      fds[i] = dmabuf_fd;
+      strides[i] = gbm_bo_get_stride_for_plane (buffer_gbm->bo, i);
+      offsets[i] = gbm_bo_get_offset (buffer_gbm->bo, i);
+      modifiers[i] = gbm_bo_get_modifier (buffer_gbm->bo);
+    }
+
+  egl_image = meta_egl_create_dmabuf_image (egl,
+                                            egl_display,
+                                            width,
+                                            height,
+                                            drm_format,
+                                            n_planes,
+                                            fds,
+                                            strides,
+                                            offsets,
+                                            modifiers,
+                                            &error);
+  if (egl_image == EGL_NO_IMAGE_KHR)
+    goto out;
+
+  flags = COGL_EGL_IMAGE_FLAG_NO_GET_DATA;
+  cogl_tex = cogl_egl_texture_2d_new_from_image (cogl_context,
+                                                 width,
+                                                 height,
+                                                 cogl_format,
+                                                 egl_image,
+                                                 flags,
+                                                 &error);
+
+  meta_egl_destroy_image (egl, egl_display, egl_image, NULL);
+
+  if (!cogl_tex)
+    goto out;
+
+  cogl_fbo = cogl_offscreen_new_with_texture (COGL_TEXTURE (cogl_tex));
+  cogl_object_unref (cogl_tex);
+
+  if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (cogl_fbo), &error))
+    goto out;
+
+  /* Set up a timestamp query for when all rendering will be finished. */
+  cogl_context->glGenQueries (1, &info->timestamp_query);
+  cogl_context->glQueryCounter (info->timestamp_query, GL_TIMESTAMP);
+
+  /* Get current GPU and CPU time. */
+  cogl_context->glGetInteger64v (GL_TIMESTAMP,
+      &info->gpu_time_before_buffer_swap_ns);
+
+  cogl_context->glFlush ();
+
+out:
+  close (dmabuf_fd);
+}
+
 static gboolean
 meta_drm_buffer_gbm_blit_to_framebuffer (CoglScanout      *scanout,
                                          CoglFramebuffer  *framebuffer,
diff --git a/src/backends/native/meta-drm-buffer-gbm.h b/src/backends/native/meta-drm-buffer-gbm.h
index 43d7e2d8a0..d79d7a3a03 100644
--- a/src/backends/native/meta-drm-buffer-gbm.h
+++ b/src/backends/native/meta-drm-buffer-gbm.h
@@ -46,4 +46,7 @@ MetaDrmBufferGbm * meta_drm_buffer_gbm_new_take (MetaKmsDevice  *device,
 
 struct gbm_bo * meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm);
 
+void meta_drm_buffer_gbm_fill_timings (MetaDrmBufferGbm *buffer_gbm,
+                                       CoglFrameInfo    *info);
+
 #endif /* META_DRM_BUFFER_GBM_H */
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index da75b03ec4..48878d3925 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -1255,6 +1255,26 @@ meta_onscreen_native_direct_scanout (CoglOnscreen   *onscreen,
 
   g_set_object (&onscreen_native->gbm.next_fb, META_DRM_BUFFER (scanout));
 
+  /* Try to get a measurement of GPU rendering time on the scanout buffer.
+   *
+   * The successful operation here adds ~0.4 ms to a ~0.1 ms total frame clock
+   * dispatch duration when displaying an unredirected client, thus
+   * unfortunately bringing it more in line with duration of the regular
+   * non-unredirected frame clock dispatch. However, measuring GPU rendering
+   * time is important for computing accurate max render time without
+   * underestimating. Also this operation should be optimizable by caching
+   * EGLImage for each buffer instead of re-creating it every time it's needed.
+   * This should also help all other cases which convert the buffer to a
+   * EGLImage.
+   */
+  if (META_IS_DRM_BUFFER_GBM (scanout))
+    {
+      meta_drm_buffer_gbm_fill_timings (META_DRM_BUFFER_GBM (scanout),
+                                        frame_info);
+    }
+
+  frame_info->cpu_time_before_buffer_swap_us = g_get_monotonic_time ();
+
   ensure_crtc_modes (onscreen);
   meta_onscreen_native_flip_crtc (onscreen,
                                   onscreen_native->view,
-- 
GitLab


From b147679a23ab59dcac88538888c785ab73e83b2a Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:40:23 +0300
Subject: [PATCH 10/16] clutter: Add swap time and GPU rendering duration to
 FrameInfo

---
 clutter/clutter/clutter-stage.h           | 3 +++
 clutter/clutter/cogl/clutter-stage-cogl.c | 4 ++++
 2 files changed, 7 insertions(+)

diff --git a/clutter/clutter/clutter-stage.h b/clutter/clutter/clutter-stage.h
index 9f25e54726..69ab1d6eba 100644
--- a/clutter/clutter/clutter-stage.h
+++ b/clutter/clutter/clutter-stage.h
@@ -149,6 +149,9 @@ struct _ClutterFrameInfo
   ClutterFrameInfoFlag flags;
 
   unsigned int sequence;
+
+  int64_t gpu_rendering_duration_ns;
+  int64_t cpu_time_before_buffer_swap_us;
 };
 
 typedef struct _ClutterCapture
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index b40dfe2b1c..1341f12c57 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -848,6 +848,10 @@ frame_cb (CoglOnscreen  *onscreen,
           cogl_frame_info_get_presentation_time_us (frame_info),
         .flags = flags,
         .sequence = cogl_frame_info_get_sequence (frame_info),
+        .gpu_rendering_duration_ns =
+          cogl_frame_info_get_rendering_duration_ns (frame_info),
+        .cpu_time_before_buffer_swap_us =
+          cogl_frame_info_get_time_before_buffer_swap_us (frame_info),
       };
       clutter_stage_view_notify_presented (view, &clutter_frame_info);
     }
-- 
GitLab


From 6099cec99cba2811cfa80c6996aa1d2f316e2979 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 6 Jan 2021 15:44:27 +0300
Subject: [PATCH 11/16] clutter/frame-clock: Store dispatch timings

Will be used to adjust max render time dynamically.
---
 clutter/clutter/clutter-frame-clock.c | 45 +++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 9dbed99ba4..e87078c09a 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -24,6 +24,8 @@
 #include "clutter/clutter-timeline-private.h"
 #include "cogl/cogl-trace.h"
 
+#define ESTIMATE_QUEUE_LENGTH 16
+
 enum
 {
   DESTROY,
@@ -83,6 +85,16 @@ struct _ClutterFrameClock
   /* Last KMS buffer submission time. */
   int64_t last_flip_time_us;
 
+  /* Last few durations between dispatch start and buffer swap. */
+  int64_t dispatch_to_swap_us[ESTIMATE_QUEUE_LENGTH];
+  int dispatch_to_swap_next_index;
+  /* Last few durations between buffer swap and GPU rendering finish. */
+  int64_t swap_to_rendering_done_us[ESTIMATE_QUEUE_LENGTH];
+  int swap_to_rendering_done_next_index;
+  /* Last few durations between buffer swap and KMS submission. */
+  int64_t swap_to_flip_us[ESTIMATE_QUEUE_LENGTH];
+  int swap_to_flip_next_index;
+
   gboolean pending_reschedule;
   gboolean pending_reschedule_now;
 
@@ -191,6 +203,39 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 {
   frame_clock->last_presentation_time_us = frame_info->presentation_time;
 
+  if (frame_info->cpu_time_before_buffer_swap_us != 0 &&
+      frame_info->gpu_rendering_duration_ns != 0)
+    {
+      int64_t dispatch_to_swap_us, swap_to_rendering_done_us, swap_to_flip_us;
+
+      dispatch_to_swap_us =
+        frame_info->cpu_time_before_buffer_swap_us -
+        frame_clock->last_dispatch_time_us;
+      swap_to_rendering_done_us =
+        frame_info->gpu_rendering_duration_ns / 1000;
+      swap_to_flip_us =
+        frame_clock->last_flip_time_us -
+        frame_info->cpu_time_before_buffer_swap_us;
+
+      frame_clock->dispatch_to_swap_us[frame_clock->dispatch_to_swap_next_index] =
+        dispatch_to_swap_us;
+      frame_clock->dispatch_to_swap_next_index =
+        (frame_clock->dispatch_to_swap_next_index + 1) %
+        ESTIMATE_QUEUE_LENGTH;
+
+      frame_clock->swap_to_rendering_done_us[frame_clock->swap_to_rendering_done_next_index] =
+        swap_to_rendering_done_us;
+      frame_clock->swap_to_rendering_done_next_index =
+        (frame_clock->swap_to_rendering_done_next_index + 1) %
+        ESTIMATE_QUEUE_LENGTH;
+
+      frame_clock->swap_to_flip_us[frame_clock->swap_to_flip_next_index] =
+        swap_to_flip_us;
+      frame_clock->swap_to_flip_next_index =
+        (frame_clock->swap_to_flip_next_index + 1) %
+        ESTIMATE_QUEUE_LENGTH;
+    }
+
   if (frame_info->refresh_rate > 1)
     frame_clock->refresh_rate = frame_info->refresh_rate;
 
-- 
GitLab


From 1cf594db5e538435211fe355b160273cd92f95f8 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Wed, 13 Jan 2021 09:32:44 +0300
Subject: [PATCH 12/16] clutter: Add FRAME_TIMINGS debug key

---
 clutter/clutter/clutter-frame-clock.c | 6 ++++++
 clutter/clutter/clutter-main.c        | 1 +
 clutter/clutter/clutter-main.h        | 1 +
 3 files changed, 8 insertions(+)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index e87078c09a..a9951c10f6 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -217,6 +217,12 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
         frame_clock->last_flip_time_us -
         frame_info->cpu_time_before_buffer_swap_us;
 
+      CLUTTER_NOTE (FRAME_TIMINGS,
+                    "dispatch2swap %ld µs, swap2render %ld µs, swap2flip %ld µs",
+                    dispatch_to_swap_us,
+                    swap_to_rendering_done_us,
+                    swap_to_flip_us);
+
       frame_clock->dispatch_to_swap_us[frame_clock->dispatch_to_swap_next_index] =
         dispatch_to_swap_us;
       frame_clock->dispatch_to_swap_next_index =
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index d79b690a3d..bbefd62d08 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -112,6 +112,7 @@ static const GDebugKey clutter_debug_keys[] = {
   { "layout", CLUTTER_DEBUG_LAYOUT },
   { "clipping", CLUTTER_DEBUG_CLIPPING },
   { "oob-transforms", CLUTTER_DEBUG_OOB_TRANSFORMS },
+  { "frame-timings", CLUTTER_DEBUG_FRAME_TIMINGS },
 };
 #endif /* CLUTTER_ENABLE_DEBUG */
 
diff --git a/clutter/clutter/clutter-main.h b/clutter/clutter/clutter-main.h
index 10e2aca997..74abc29a07 100644
--- a/clutter/clutter/clutter-main.h
+++ b/clutter/clutter/clutter-main.h
@@ -53,6 +53,7 @@ typedef enum
   CLUTTER_DEBUG_EVENTLOOP           = 1 << 14,
   CLUTTER_DEBUG_CLIPPING            = 1 << 15,
   CLUTTER_DEBUG_OOB_TRANSFORMS      = 1 << 16,
+  CLUTTER_DEBUG_FRAME_TIMINGS       = 1 << 17,
 } ClutterDebugFlag;
 
 typedef enum
-- 
GitLab


From 44ee1eafd752f9cfe6cfc074cf44971251afa629 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Fri, 27 Nov 2020 20:58:55 +0300
Subject: [PATCH 13/16] clutter: Compute max render time heuristically
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Max render time shows how early the frame clock needs to be dispatched
to make it to the predicted next presentation time. Before this commit
it was set to refresh interval minus 2 ms. This means Mutter would
always start compositing 14.7 ms before a display refresh on a 60 Hz
screen or 4.9 ms before a display refresh on a 144 Hz screen. However,
Mutter frequently does not need as much time to finish compositing and
submit buffer to KMS:

      max render time
      /------------\
---|---------------|---------------|---> presentations
      D----S          D--S

      D - frame clock dispatch
      S - buffer submission

This commit aims to automatically compute a shorter max render time to
make Mutter start compositing as late as possible (but still making it
in time for the presentation):

         max render time
             /-----\
---|---------------|---------------|---> presentations
             D----S          D--S

Why is this better? First of all, Mutter gets application contents to
draw at the time when compositing starts. If new application buffer
arrives after the compositing has started, but before the next
presentation, it won't make it on screen:

---|---------------|---------------|---> presentations
      D----S          D--S
        A-------------X----------->

                   ^ doesn't make it for this presentation

        A - application buffer commit
        X - application buffer sampled by Mutter

Here the application committed just a few ms too late and didn't make on
screen until the next presentation. If compositing starts later in the
frame cycle, applications can commit buffers closer to the presentation.
These buffers will be more up-to-date thereby reducing input latency.

---|---------------|---------------|---> presentations
             D----S          D--S
        A----X---->

                   ^ made it!

Moreover, applications are recommended to render their frames on frame
callbacks, which Mutter sends right after compositing is done. Since
this commit delays the compositing, it also reduces the latency for
applications drawing on frame callbacks. Compare:

---|---------------|---------------|---> presentations
      D----S          D--S
           F--A-------X----------->
              \____________________/
                     latency

---|---------------|---------------|---> presentations
             D----S          D--S
                  F--A-------X---->
                     \_____________/
                      less latency

           F - frame callback received, application starts rendering

So how do we actually estimate max render time? We want it to be as low
as possible, but still large enough so as not to miss any frames by
accident:

         max render time
             /-----\
---|---------------|---------------|---> presentations
             D------S------------->
                   oops, took a little too long

For a successful presentation, the frame needs to be submitted to KMS
and the GPU work must be completed before the vblank. This deadline can
be computed by subtracting the vblank duration (calculated from display
mode) from the predicted next presentation time.

We don't know how long compositing will take, and we also don't know how
long the GPU work will take, since clients can submit buffers with
unfinished GPU work. So we measure and estimate these values.

The frame clock dispatch can be split into two phases:
1. From start of the dispatch to all GPU commands being submitted (but
   not finished)—until the call to eglSwapBuffers().
2. From eglSwapBuffers() to submitting the buffer to KMS and to GPU
   work completing. These happen in parallel, and we want the latest of
   the two to be done before the vblank.

We measure these three durations and store them for the last 16 frames.
The estimate for each duration is a maximum of these last 16 durations.
Usually even taking just the last frame's durations as the estimates
works well enough, but I found that screen-capturing with OBS Studio
increases duration variability enough to cause frequent missed frames
when using that method. Taking a maximum of the last 16 frames smoothes
out this variability.

The durations are naturally quite variable and the estimates aren't
perfect. To take this into account, an additional constant 2 ms is added
to the max render time.

How does it perform in practice? On my desktop with 144 Hz monitors I
get a max render time of 4–5 ms instead of the default 4.9 ms (I had
1 ms manually configured in sway) and on my laptop with a 60 Hz screen I
get a max render time of 4.8–5.5 ms instead of the default 14.7 ms (I
had 5–6 ms manually configured in sway). Weston [1] went with a 7 ms
default.

The main downside is that if there's a sudden heavy batch of work in the
compositing, which would've made it in default 14.7 ms, but doesn't make
it in reduced 6 ms, there is a delayed frame which would otherwise not
be there. Arguably, this happens rarely enough to be a good trade-off
for reduced latency. One possible solution is a "next frame is expected
to be heavy" function which manually increases max render time for the
next frame. This would avoid this single dropped frame at the start of
complex animations.

[1]: https://www.collabora.com/about-us/blog/2015/02/12/weston-repaint-scheduling/
---
 clutter/clutter/clutter-frame-clock.c | 61 +++++++++++++++++++++++++--
 clutter/clutter/clutter-frame-clock.h |  2 +
 2 files changed, 59 insertions(+), 4 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index a9951c10f6..e204a59db5 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -35,9 +35,6 @@ enum
 
 static guint signals[N_SIGNALS];
 
-/* Wait 2ms after vblank before starting to draw next frame */
-#define SYNC_DELAY_US ms2us (2)
-
 typedef struct _ClutterFrameListener
 {
   const ClutterFrameListenerIface *iface;
@@ -94,6 +91,8 @@ struct _ClutterFrameClock
   /* Last few durations between buffer swap and KMS submission. */
   int64_t swap_to_flip_us[ESTIMATE_QUEUE_LENGTH];
   int swap_to_flip_next_index;
+  /* If we got new measurements last frame. */
+  gboolean got_measurements_last_frame;
 
   gboolean pending_reschedule;
   gboolean pending_reschedule_now;
@@ -203,6 +202,8 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 {
   frame_clock->last_presentation_time_us = frame_info->presentation_time;
 
+  frame_clock->got_measurements_last_frame = FALSE;
+
   if (frame_info->cpu_time_before_buffer_swap_us != 0 &&
       frame_info->gpu_rendering_duration_ns != 0)
     {
@@ -240,6 +241,8 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
       frame_clock->swap_to_flip_next_index =
         (frame_clock->swap_to_flip_next_index + 1) %
         ESTIMATE_QUEUE_LENGTH;
+
+      frame_clock->got_measurements_last_frame = TRUE;
     }
 
   if (frame_info->refresh_rate > 1)
@@ -311,7 +314,8 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
     }
 
   min_render_time_allowed_us = refresh_interval_us / 2;
-  max_render_time_allowed_us = refresh_interval_us - SYNC_DELAY_US;
+  max_render_time_allowed_us =
+    clutter_frame_clock_max_render_time_us (frame_clock);
 
   if (min_render_time_allowed_us > max_render_time_allowed_us)
     min_render_time_allowed_us = max_render_time_allowed_us;
@@ -613,6 +617,55 @@ clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
   frame_clock->last_flip_time_us = flip_time_us;
 }
 
+int
+clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock)
+{
+  int refresh_interval_us;
+  int64_t max_dispatch_to_swap_us = 0;
+  int64_t max_swap_to_rendering_done_us = 0;
+  int64_t max_swap_to_flip_us = 0;
+  int max_render_time_us;
+
+  refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / frame_clock->refresh_rate);
+
+  if (!frame_clock->got_measurements_last_frame)
+    /* We don't have up-to-date data. */
+    return refresh_interval_us - 2000;
+
+  for (int i = 0; i < ESTIMATE_QUEUE_LENGTH; ++i)
+    {
+      max_dispatch_to_swap_us =
+        MAX (max_dispatch_to_swap_us, frame_clock->dispatch_to_swap_us[i]);
+      max_swap_to_rendering_done_us =
+        MAX (max_swap_to_rendering_done_us, frame_clock->swap_to_rendering_done_us[i]);
+      max_swap_to_flip_us =
+        MAX (max_swap_to_flip_us, frame_clock->swap_to_flip_us[i]);
+    }
+
+  /* Max render time shows how early the frame clock needs to be dispatched
+   * to make it to the predicted next presentation time. It is composed of:
+   * - An estimate of duration from dispatch start to buffer swap.
+   * - Maximum between estimates of duration from buffer swap to GPU rendering
+   *   finish and duration from buffer swap to buffer submission to KMS. This
+   *   is because both of these things need to happen before the vblank, and
+   *   they are done in parallel.
+   * - Duration of the vblank.
+   * - A constant to account for variations in the above estimates.
+   */
+  max_render_time_us =
+    max_dispatch_to_swap_us +
+    MAX (max_swap_to_rendering_done_us, max_swap_to_flip_us) +
+    frame_clock->vblank_duration_us +
+    2000;
+
+  /* Sanity checks. */
+  max_render_time_us = MIN (max_render_time_us, refresh_interval_us);
+  max_render_time_us = MAX (max_render_time_us, 0);
+
+  return max_render_time_us;
+}
+
 static GSourceFuncs frame_clock_source_funcs = {
   NULL,
   NULL,
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index c825ecad94..55bfae6b4a 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -94,4 +94,6 @@ float clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock);
 void clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
                                            int64_t            flip_time_us);
 
+int clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock);
+
 #endif /* CLUTTER_FRAME_CLOCK_H */
-- 
GitLab


From 9bd4634f61a9d1ec0aa2d0f74002833fa8d18e1d Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Sat, 28 Nov 2020 16:46:03 +0300
Subject: [PATCH 14/16] clutter: Add a flag to disable heuristic max render
 time

Debugging purposes: allows to check if frame drops are caused by
heuristic max render time or if they are there even with the old
behavior.
---
 clutter/clutter/clutter-frame-clock.c |  5 ++++-
 clutter/clutter/clutter-main.c        |  1 +
 clutter/clutter/clutter-main.h        | 19 ++++++++++---------
 3 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index e204a59db5..0be796aecc 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -19,6 +19,7 @@
 
 #include "clutter/clutter-frame-clock.h"
 
+#include "clutter/clutter-debug.h"
 #include "clutter/clutter-main.h"
 #include "clutter/clutter-private.h"
 #include "clutter/clutter-timeline-private.h"
@@ -629,7 +630,9 @@ clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock)
   refresh_interval_us =
     (int64_t) (0.5 + G_USEC_PER_SEC / frame_clock->refresh_rate);
 
-  if (!frame_clock->got_measurements_last_frame)
+  if (!frame_clock->got_measurements_last_frame ||
+      G_UNLIKELY (clutter_paint_debug_flags &
+                  CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME))
     /* We don't have up-to-date data. */
     return refresh_interval_us - 2000;
 
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index bbefd62d08..ddde16fad4 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -130,6 +130,7 @@ static const GDebugKey clutter_paint_debug_keys[] = {
   { "continuous-redraw", CLUTTER_DEBUG_CONTINUOUS_REDRAW },
   { "paint-deform-tiles", CLUTTER_DEBUG_PAINT_DEFORM_TILES },
   { "damage-region", CLUTTER_DEBUG_PAINT_DAMAGE_REGION },
+  { "disable-dynamic-max-render-time", CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME },
 };
 
 gboolean
diff --git a/clutter/clutter/clutter-main.h b/clutter/clutter/clutter-main.h
index 74abc29a07..35931bb516 100644
--- a/clutter/clutter/clutter-main.h
+++ b/clutter/clutter/clutter-main.h
@@ -63,15 +63,16 @@ typedef enum
 
 typedef enum
 {
-  CLUTTER_DEBUG_DISABLE_SWAP_EVENTS        = 1 << 0,
-  CLUTTER_DEBUG_DISABLE_CLIPPED_REDRAWS    = 1 << 1,
-  CLUTTER_DEBUG_REDRAWS                    = 1 << 2,
-  CLUTTER_DEBUG_PAINT_VOLUMES              = 1 << 3,
-  CLUTTER_DEBUG_DISABLE_CULLING            = 1 << 4,
-  CLUTTER_DEBUG_DISABLE_OFFSCREEN_REDIRECT = 1 << 5,
-  CLUTTER_DEBUG_CONTINUOUS_REDRAW          = 1 << 6,
-  CLUTTER_DEBUG_PAINT_DEFORM_TILES         = 1 << 7,
-  CLUTTER_DEBUG_PAINT_DAMAGE_REGION        = 1 << 8,
+  CLUTTER_DEBUG_DISABLE_SWAP_EVENTS             = 1 << 0,
+  CLUTTER_DEBUG_DISABLE_CLIPPED_REDRAWS         = 1 << 1,
+  CLUTTER_DEBUG_REDRAWS                         = 1 << 2,
+  CLUTTER_DEBUG_PAINT_VOLUMES                   = 1 << 3,
+  CLUTTER_DEBUG_DISABLE_CULLING                 = 1 << 4,
+  CLUTTER_DEBUG_DISABLE_OFFSCREEN_REDIRECT      = 1 << 5,
+  CLUTTER_DEBUG_CONTINUOUS_REDRAW               = 1 << 6,
+  CLUTTER_DEBUG_PAINT_DEFORM_TILES              = 1 << 7,
+  CLUTTER_DEBUG_PAINT_DAMAGE_REGION             = 1 << 8,
+  CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME = 1 << 9,
 } ClutterDrawDebugFlag;
 
 /**
-- 
GitLab


From a7c030c3c41e5aa0c4c6856d09d22eb2bfc1497d Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Sat, 28 Nov 2020 22:15:02 +0300
Subject: [PATCH 15/16] clutter: Add an lg command to set max render time
 constant

---
 clutter/clutter/clutter-debug.h       | 1 +
 clutter/clutter/clutter-frame-clock.c | 2 +-
 clutter/clutter/clutter-main.c        | 7 +++++++
 clutter/clutter/clutter-main.h        | 3 +++
 4 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/clutter/clutter/clutter-debug.h b/clutter/clutter/clutter-debug.h
index 76b8505cb0..0411b6e318 100644
--- a/clutter/clutter/clutter-debug.h
+++ b/clutter/clutter/clutter-debug.h
@@ -41,6 +41,7 @@ G_BEGIN_DECLS
 extern guint clutter_debug_flags;
 extern guint clutter_pick_debug_flags;
 extern guint clutter_paint_debug_flags;
+extern int clutter_max_render_time_constant;
 
 void    _clutter_debug_messagev         (const char *format,
                                          va_list     var_args) G_GNUC_PRINTF (1, 0);
diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 0be796aecc..ee9891b09c 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -660,7 +660,7 @@ clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock)
     max_dispatch_to_swap_us +
     MAX (max_swap_to_rendering_done_us, max_swap_to_flip_us) +
     frame_clock->vblank_duration_us +
-    2000;
+    clutter_max_render_time_constant;
 
   /* Sanity checks. */
   max_render_time_us = MIN (max_render_time_us, refresh_interval_us);
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index ddde16fad4..365d664bd4 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -94,6 +94,7 @@ static ClutterTextDirection clutter_text_direction = CLUTTER_TEXT_DIRECTION_LTR;
 guint clutter_debug_flags       = 0;
 guint clutter_paint_debug_flags = 0;
 guint clutter_pick_debug_flags  = 0;
+int clutter_max_render_time_constant = 2000;
 
 #ifdef CLUTTER_ENABLE_DEBUG
 static const GDebugKey clutter_debug_keys[] = {
@@ -2275,6 +2276,12 @@ clutter_remove_debug_flags (ClutterDebugFlag     debug_flags,
   clutter_pick_debug_flags &= ~pick_flags;
 }
 
+void
+clutter_set_max_render_time_constant (int max_render_time_constant)
+{
+  clutter_max_render_time_constant = max_render_time_constant;
+}
+
 void
 _clutter_set_sync_to_vblank (gboolean sync_to_vblank)
 {
diff --git a/clutter/clutter/clutter-main.h b/clutter/clutter/clutter-main.h
index 35931bb516..6c0e437bbc 100644
--- a/clutter/clutter/clutter-main.h
+++ b/clutter/clutter/clutter-main.h
@@ -198,6 +198,9 @@ void                    clutter_remove_debug_flags              (ClutterDebugFla
                                                                  ClutterDrawDebugFlag draw_flags,
                                                                  ClutterPickDebugFlag pick_flags);
 
+CLUTTER_EXPORT
+void                    clutter_set_max_render_time_constant    (int max_render_time_constant);
+
 G_END_DECLS
 
 #endif /* _CLUTTER_MAIN_H__ */
-- 
GitLab


From 469dc99a370120ad9da2209b92a6cf11da852a27 Mon Sep 17 00:00:00 2001
From: Ivan Molodetskikh <yalterz@gmail.com>
Date: Fri, 27 Nov 2020 21:49:19 +0300
Subject: [PATCH 16/16] clutter: Add a max render time debug HUD

Not sure how to update the damage or redraw clip or something; at least
this works properly when under a constantly-redrawing window, which is
ok for debugging purposes.
---
 clutter/clutter/clutter-frame-clock.c | 41 ++++++++++++++++++++++++
 clutter/clutter/clutter-frame-clock.h |  2 ++
 clutter/clutter/clutter-main.c        |  1 +
 clutter/clutter/clutter-main.h        |  1 +
 clutter/clutter/clutter-stage.c       | 46 +++++++++++++++++++++++++++
 5 files changed, 91 insertions(+)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index ee9891b09c..72ec937d3f 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -669,6 +669,47 @@ clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock)
   return max_render_time_us;
 }
 
+GString *
+clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock)
+{
+  int64_t max_dispatch_to_swap_us = 0;
+  int64_t max_swap_to_rendering_done_us = 0;
+  int64_t max_swap_to_flip_us = 0;
+  GString *string;
+
+  string = g_string_new (NULL);
+  g_string_append_printf (string, "Max render time: %d µs",
+                          clutter_frame_clock_max_render_time_us (frame_clock));
+
+  if (frame_clock->got_measurements_last_frame)
+    g_string_append_printf (string, " =");
+  else
+    g_string_append_printf (string, " (no measurements last frame)");
+
+  for (int i = 0; i < ESTIMATE_QUEUE_LENGTH; ++i)
+    {
+      max_dispatch_to_swap_us =
+        MAX (max_dispatch_to_swap_us, frame_clock->dispatch_to_swap_us[i]);
+      max_swap_to_rendering_done_us =
+        MAX (max_swap_to_rendering_done_us, frame_clock->swap_to_rendering_done_us[i]);
+      max_swap_to_flip_us =
+        MAX (max_swap_to_flip_us, frame_clock->swap_to_flip_us[i]);
+    }
+
+  g_string_append_printf (string, "\nVblank duration: %ld µs +",
+                          frame_clock->vblank_duration_us);
+  g_string_append_printf (string, "\nDispatch to swap: %ld µs +",
+                          max_dispatch_to_swap_us);
+  g_string_append_printf (string, "\nmax(Swap to rendering done: %ld µs,",
+                          max_swap_to_rendering_done_us);
+  g_string_append_printf (string, "\nSwap to flip: %ld µs) +",
+                          max_swap_to_flip_us);
+  g_string_append_printf (string, "\nConstant: %d µs",
+                          clutter_max_render_time_constant);
+
+  return string;
+}
+
 static GSourceFuncs frame_clock_source_funcs = {
   NULL,
   NULL,
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index 55bfae6b4a..35f0c780c1 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -96,4 +96,6 @@ void clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
 
 int clutter_frame_clock_max_render_time_us (ClutterFrameClock *frame_clock);
 
+GString *clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock);
+
 #endif /* CLUTTER_FRAME_CLOCK_H */
diff --git a/clutter/clutter/clutter-main.c b/clutter/clutter/clutter-main.c
index 365d664bd4..cc3e2d0525 100644
--- a/clutter/clutter/clutter-main.c
+++ b/clutter/clutter/clutter-main.c
@@ -132,6 +132,7 @@ static const GDebugKey clutter_paint_debug_keys[] = {
   { "paint-deform-tiles", CLUTTER_DEBUG_PAINT_DEFORM_TILES },
   { "damage-region", CLUTTER_DEBUG_PAINT_DAMAGE_REGION },
   { "disable-dynamic-max-render-time", CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME },
+  { "max-render-time", CLUTTER_DEBUG_PAINT_MAX_RENDER_TIME },
 };
 
 gboolean
diff --git a/clutter/clutter/clutter-main.h b/clutter/clutter/clutter-main.h
index 6c0e437bbc..7157b0647a 100644
--- a/clutter/clutter/clutter-main.h
+++ b/clutter/clutter/clutter-main.h
@@ -73,6 +73,7 @@ typedef enum
   CLUTTER_DEBUG_PAINT_DEFORM_TILES              = 1 << 7,
   CLUTTER_DEBUG_PAINT_DAMAGE_REGION             = 1 << 8,
   CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME = 1 << 9,
+  CLUTTER_DEBUG_PAINT_MAX_RENDER_TIME           = 1 << 10,
 } ClutterDrawDebugFlag;
 
 /**
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 8627c6a17f..a8b8d11e85 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -1312,6 +1312,51 @@ clutter_stage_real_paint_view (ClutterStage         *stage,
   clutter_stage_do_paint_view (stage, view, redraw_clip);
 }
 
+static void
+clutter_stage_paint (ClutterActor        *actor,
+                     ClutterPaintContext *paint_context)
+{
+  ClutterStageView *view;
+
+  CLUTTER_ACTOR_CLASS (clutter_stage_parent_class)->paint (actor, paint_context);
+
+  view = clutter_paint_context_get_stage_view (paint_context);
+  if (view &&
+      G_UNLIKELY (clutter_paint_debug_flags & CLUTTER_DEBUG_PAINT_MAX_RENDER_TIME))
+    {
+      cairo_rectangle_int_t view_layout;
+      ClutterFrameClock *frame_clock;
+      g_autoptr (GString) string = NULL;
+      PangoLayout *layout;
+      PangoRectangle logical;
+      ClutterColor color;
+      g_autoptr (ClutterPaintNode) node = NULL;
+      ClutterActorBox box;
+
+      clutter_stage_view_get_layout (view, &view_layout);
+      frame_clock = clutter_stage_view_get_frame_clock (view);
+
+      string = clutter_frame_clock_get_max_render_time_debug_info (frame_clock);
+
+      layout = clutter_actor_create_pango_layout (actor, string->str);
+      pango_layout_set_alignment(layout, PANGO_ALIGN_RIGHT);
+      pango_layout_get_pixel_extents (layout, NULL, &logical);
+
+      clutter_color_init (&color, 255, 255, 255, 255);
+      node = clutter_text_node_new (layout, &color);
+
+      box.x1 = view_layout.x;
+      box.y1 = view_layout.y + 30;
+      box.x2 = box.x1 + logical.width;
+      box.y2 = box.y1 + logical.height;
+      clutter_paint_node_add_rectangle (node, &box);
+
+      clutter_paint_node_paint (node, paint_context);
+
+      g_object_unref (layout);
+    }
+}
+
 static void
 clutter_stage_class_init (ClutterStageClass *klass)
 {
@@ -1335,6 +1380,7 @@ clutter_stage_class_init (ClutterStageClass *klass)
   actor_class->hide_all = clutter_stage_hide_all;
   actor_class->queue_relayout = clutter_stage_real_queue_relayout;
   actor_class->apply_transform = clutter_stage_real_apply_transform;
+  actor_class->paint = clutter_stage_paint;
 
   klass->paint_view = clutter_stage_real_paint_view;
 
-- 
GitLab

